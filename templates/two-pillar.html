<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ASCII Scroll</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a0c;
      color: #e8e8e0;
      font-family: 'JetBrains Mono', monospace;
    }
    .scroll-container { height: {{SCROLL_HEIGHT}}; }

    .pillar {
      position: fixed;
      top: 0;
      width: {{PILLAR_WIDTH}};
      height: 100vh;
      z-index: 1;
    }
    .pillar canvas {
      width: 100%;
      height: 100%;
    }
    .pillar--left { left: 0; }
    .pillar--right { right: 0; }

    .content-layer {
      position: fixed;
      top: 0;
      left: {{PILLAR_WIDTH}};
      width: calc(100vw - {{PILLAR_WIDTH}} - {{PILLAR_WIDTH}});
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
      pointer-events: none;
    }
    .content-inner {
      text-align: center;
      padding: 40px;
      pointer-events: auto;
    }
    .content-inner h2 {
      font-size: 1.2rem;
      font-weight: 400;
      margin-bottom: 16px;
      opacity: 0;
      transition: opacity 1s ease-out;
    }
    .content-inner p {
      font-size: 0.7rem;
      color: #666;
      line-height: 1.8;
      opacity: 0;
      transition: opacity 1s ease-out 0.3s;
    }
    .content-inner.visible h2,
    .content-inner.visible p { opacity: 1; }

    video { display: none; }

    .progress-bar {
      position: fixed;
      top: 0; left: 0;
      height: 1px;
      background: #2ecc71;
      z-index: 100;
      box-shadow: 0 0 6px rgba(46,204,113,0.4);
    }
    .scroll-hint {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: #333;
      font-family: monospace;
      z-index: 10;
      transition: opacity 0.5s;
    }

    #charset-select {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 200;
      background: #1a1a1e;
      color: #e8e8e0;
      border: 1px solid #333;
      padding: 6px 10px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      border-radius: 4px;
      cursor: pointer;
      outline: none;
    }
    #charset-select:hover { border-color: #555; }
    #charset-select option {
      background: #1a1a1e;
      color: #e8e8e0;
    }
  </style>
</head>
<body>

<div class="progress-bar" id="progress-bar"></div>

<select id="charset-select">
  <option value="classic">Classic  .,:;+*?%S#@</option>
  <option value="blocks">Blocks  ░▒▓█</option>
  <option value="minimal">Minimal  .-=+#</option>
  <option value="dense">Dense  .:-=+*#%@</option>
  <option value="dots">Dots  ·:;o*O@</option>
  <option value="binary">Binary  01</option>
  <option value="slash">Slashes  /|\-=*#</option>
  <option value="braille">Braille  ⠁⠃⠇⡇⣇⣧⣷⣿</option>
</select>

<div class="scroll-container" id="scroll-container">
  <div class="pillar pillar--left"><canvas id="canvas-left"></canvas></div>
  <div class="pillar pillar--right"><canvas id="canvas-right"></canvas></div>

  <div class="content-layer">
    <div class="content-inner" id="content-inner">
      {{CONTENT_HTML}}
    </div>
  </div>
</div>

<div class="scroll-hint" id="scroll-hint">scroll to animate</div>

<video id="video" muted playsinline preload="auto">
  <source src="{{VIDEO_SRC}}" type="video/mp4">
</video>

<script>
const CHARSETS = {
  classic:  ' .,:;+*?%S#@',
  blocks:   ' \u2591\u2592\u2593\u2588',
  minimal:  ' .-=+#',
  dense:    ' .:-=+*#%@',
  dots:     ' \u00B7:;o*O@',
  binary:   ' 01',
  slash:    ' /|\\-=*#',
  braille:  ' \u2801\u2803\u2807\u2847\u28C7\u28E7\u28F7\u28FF',
};

let ASCII_CHARS = CHARSETS['{{DEFAULT_CHARSET}}'] || CHARSETS.classic;
const FONT_SIZE = {{FONT_SIZE}};
const CHAR_ASPECT = {{CHAR_ASPECT}};
const LERP_FACTOR = {{LERP_FACTOR}};
const DARK_THRESHOLD = {{DARK_THRESHOLD}};
const SATURATION = {{SATURATION}};
const BRIGHTNESS = {{BRIGHTNESS}};

const video = document.getElementById('video');
const progressBar = document.getElementById('progress-bar');
const scrollHint = document.getElementById('scroll-hint');
const contentInner = document.getElementById('content-inner');
const charsetSelect = document.getElementById('charset-select');

// Set default selection
charsetSelect.value = '{{DEFAULT_CHARSET}}' || 'classic';

const cellH = FONT_SIZE;
const cellW = Math.round(cellH * CHAR_ASPECT);

function buildCharAtlas(chars, cw, ch) {
  const c = document.createElement('canvas');
  c.width = cw * chars.length;
  c.height = ch;
  const ctx = c.getContext('2d');
  ctx.clearRect(0, 0, c.width, c.height);
  ctx.fillStyle = '#fff';
  ctx.font = `${ch}px monospace`;
  ctx.textBaseline = 'top';
  for (let i = 0; i < chars.length; i++) {
    ctx.fillText(chars[i], i * cw, 0);
  }
  return c;
}

let atlasCanvas = buildCharAtlas(ASCII_CHARS, cellW, cellH);

const vsSource = `#version 300 es
  in vec2 a_position;
  in vec2 a_texcoord;
  out vec2 v_texcoord;
  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
    v_texcoord = a_texcoord;
  }
`;

const fsSource = `#version 300 es
  precision highp float;

  uniform sampler2D u_video;
  uniform sampler2D u_atlas;
  uniform vec2 u_resolution;
  uniform vec2 u_cellSize;
  uniform float u_numChars;
  uniform vec2 u_atlasSize;
  uniform vec2 u_videoSize;
  uniform float u_cropX;
  uniform float u_cropW;
  uniform float u_darkThreshold;
  uniform float u_saturation;
  uniform float u_brightness;

  in vec2 v_texcoord;
  out vec4 fragColor;

  void main() {
    vec2 pixelPos = v_texcoord * u_resolution;
    vec2 cellIndex = floor(pixelPos / u_cellSize);
    vec2 cellPos = fract(pixelPos / u_cellSize);
    vec2 totalCells = floor(u_resolution / u_cellSize);

    vec2 canvasUV = cellIndex / max(totalCells - 1.0, 1.0);

    float halfVideoAspect = (u_videoSize.x * u_cropW) / u_videoSize.y;
    float canvasAspect = u_resolution.x / u_resolution.y;

    vec2 videoUV;

    if (canvasAspect > halfVideoAspect) {
      float scale = halfVideoAspect / canvasAspect;
      videoUV.x = u_cropX + canvasUV.x * u_cropW;
      videoUV.y = canvasUV.y * scale + (1.0 - scale) * 0.5;
    } else {
      float scale = canvasAspect / halfVideoAspect;
      videoUV.x = u_cropX + (canvasUV.x * scale + (1.0 - scale) * 0.5) * u_cropW;
      videoUV.y = canvasUV.y;
    }

    if (videoUV.x < u_cropX || videoUV.x > u_cropX + u_cropW ||
        videoUV.y < 0.0 || videoUV.y > 1.0) {
      fragColor = vec4(0.0, 0.0, 0.0, 0.0);
      return;
    }

    vec4 videoColor = texture(u_video, videoUV);
    float lum = dot(videoColor.rgb, vec3(0.299, 0.587, 0.114));

    if (lum < u_darkThreshold) {
      fragColor = vec4(0.0, 0.0, 0.0, 0.0);
      return;
    }

    float charIndex = floor(lum * (u_numChars - 1.0));
    charIndex = clamp(charIndex, 0.0, u_numChars - 1.0);

    float charWidth = u_cellSize.x / u_atlasSize.x;
    float atlasX = charIndex * charWidth + cellPos.x * charWidth;
    float atlasY = cellPos.y;
    float charAlpha = texture(u_atlas, vec2(atlasX, atlasY)).r;

    vec3 saturated = mix(vec3(lum), videoColor.rgb, u_saturation);
    saturated = clamp(saturated * u_brightness, 0.0, 1.0);

    fragColor = vec4(saturated, charAlpha);
  }
`;

function createPillarRenderer(canvasEl, cropX, cropW) {
  const gl = canvasEl.getContext('webgl2', { alpha: true, premultipliedAlpha: false });
  if (!gl) throw new Error('No WebGL2');

  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.clearColor(0, 0, 0, 0);

  function compile(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(s));
    }
    return s;
  }

  const prog = gl.createProgram();
  gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsSource));
  gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsSource));
  gl.linkProgram(prog);

  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1, 0,1,  1,-1, 1,1,  -1,1, 0,0,  1,1, 1,0,
  ]), gl.STATIC_DRAW);

  const aP = gl.getAttribLocation(prog, 'a_position');
  const aT = gl.getAttribLocation(prog, 'a_texcoord');
  gl.enableVertexAttribArray(aP);
  gl.vertexAttribPointer(aP, 2, gl.FLOAT, false, 16, 0);
  gl.enableVertexAttribArray(aT);
  gl.vertexAttribPointer(aT, 2, gl.FLOAT, false, 16, 8);

  const u = {};
  ['u_video','u_atlas','u_resolution','u_cellSize','u_numChars','u_atlasSize',
   'u_videoSize','u_cropX','u_cropW','u_darkThreshold','u_saturation','u_brightness'
  ].forEach(name => {
    u[name] = gl.getUniformLocation(prog, name);
  });

  const atlasTex = gl.createTexture();
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, atlasTex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, atlasCanvas);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  const videoTex = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, videoTex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  function resize() {
    const dpr = Math.min(window.devicePixelRatio, 2);
    canvasEl.width = canvasEl.clientWidth * dpr;
    canvasEl.height = canvasEl.clientHeight * dpr;
    gl.viewport(0, 0, canvasEl.width, canvasEl.height);
  }
  window.addEventListener('resize', resize);
  resize();

  return {
    draw() {
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, videoTex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);

      gl.useProgram(prog);
      gl.uniform1i(u.u_video, 0);
      gl.uniform1i(u.u_atlas, 1);
      gl.uniform2f(u.u_resolution, canvasEl.width, canvasEl.height);
      gl.uniform2f(u.u_cellSize, cellW, cellH);
      gl.uniform1f(u.u_numChars, ASCII_CHARS.length);
      gl.uniform2f(u.u_atlasSize, atlasCanvas.width, atlasCanvas.height);
      gl.uniform2f(u.u_videoSize, video.videoWidth, video.videoHeight);
      gl.uniform1f(u.u_cropX, cropX);
      gl.uniform1f(u.u_cropW, cropW);
      gl.uniform1f(u.u_darkThreshold, DARK_THRESHOLD);
      gl.uniform1f(u.u_saturation, SATURATION);
      gl.uniform1f(u.u_brightness, BRIGHTNESS);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    },
    updateAtlas() {
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, atlasTex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, atlasCanvas);
    },
    resize,
  };
}

const leftRenderer = createPillarRenderer(document.getElementById('canvas-left'), 0.0, 0.5);
const rightRenderer = createPillarRenderer(document.getElementById('canvas-right'), 0.5, 0.5);

charsetSelect.addEventListener('change', () => {
  ASCII_CHARS = CHARSETS[charsetSelect.value];
  atlasCanvas = buildCharAtlas(ASCII_CHARS, cellW, cellH);
  leftRenderer.updateAtlas();
  rightRenderer.updateAtlas();
  needsDraw = true;
});

let targetProgress = 0;
let currentProgress = 0;
let videoReady = false;
let seeking = false;
let needsDraw = true;

window.addEventListener('scroll', () => {
  const max = document.getElementById('scroll-container').scrollHeight - window.innerHeight;
  targetProgress = Math.min(1, Math.max(0, window.scrollY / max));
}, { passive: true });

video.addEventListener('seeked', () => {
  seeking = false;
  needsDraw = true;
});

video.addEventListener('loadeddata', () => {
  videoReady = true;
  video.currentTime = 0;
  needsDraw = true;
});

video.load();

function render() {
  requestAnimationFrame(render);
  if (!videoReady) return;

  currentProgress += (targetProgress - currentProgress) * LERP_FACTOR;

  const targetTime = currentProgress * video.duration;
  if (!seeking && Math.abs(video.currentTime - targetTime) > 0.03) {
    seeking = true;
    video.currentTime = targetTime;
  }

  if (needsDraw) {
    needsDraw = false;
    leftRenderer.draw();
    rightRenderer.draw();
  }

  progressBar.style.width = (currentProgress * 100) + '%';
  scrollHint.style.opacity = currentProgress < 0.03 ? '1' : '0';

  if (currentProgress > 0.15 && currentProgress < 0.9) {
    contentInner.classList.add('visible');
  } else {
    contentInner.classList.remove('visible');
  }
}

render();
</script>
</body>
</html>
